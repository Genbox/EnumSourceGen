// <auto-generated />

namespace Some.Namespace.Here;

[Flags]
public enum ClassOnlyEnumFormat : byte
{
    None = 0,
    Name = 1,
    Value = 2,
    Default = Name | Value
}
// <auto-generated />
#nullable enable

namespace Some.Namespace.Here;

public static partial class Enums
{
    public static partial class ClassOnlyEnum
    {
        public const int MemberCount = 1;
        public const bool IsFlagEnum = false;

        private static string[]? _names;
        public static string[] GetMemberNames()
            => _names ??= new[] {
                "ClassOnly"
            };

        private static Some.Namespace.Here.ClassOnlyEnum[]? _values;
        public static Some.Namespace.Here.ClassOnlyEnum[] GetMemberValues()
            => _values ??= new[] {
                Some.Namespace.Here.ClassOnlyEnum.ClassOnly
            };

        private static Int32[]? _underlyingValues;
        public static Int32[] GetUnderlyingValues()
            => _underlyingValues ??= new Int32[] {
                0
            };

        public static bool TryParse(string value, out Some.Namespace.Here.ClassOnlyEnum result, Some.Namespace.Here.ClassOnlyEnumFormat format = Some.Namespace.Here.ClassOnlyEnumFormat.Default, StringComparison comparison = StringComparison.Ordinal)
        {

            if (format.HasFlag(Some.Namespace.Here.ClassOnlyEnumFormat.Name))
            {
                if (string.Equals(value, "ClassOnly", comparison))
                {
                    result = Some.Namespace.Here.ClassOnlyEnum.ClassOnly;
                    return true;
                }
            }
            if (format.HasFlag(Some.Namespace.Here.ClassOnlyEnumFormat.Value))
            {                if (string.Equals(value, "0", comparison))
                {
                    result = Some.Namespace.Here.ClassOnlyEnum.ClassOnly;
                    return true;
                }
            }

            result = default;
            return false;
        }

        public static Some.Namespace.Here.ClassOnlyEnum Parse(string value, Some.Namespace.Here.ClassOnlyEnumFormat format = Some.Namespace.Here.ClassOnlyEnumFormat.Default, StringComparison comparison = StringComparison.Ordinal)
        {
            if (!TryParse(value, out Some.Namespace.Here.ClassOnlyEnum result, format, comparison))
                throw new ArgumentOutOfRangeException($"Invalid value: {value}");

            return result;
        }

        public static bool IsDefined(Some.Namespace.Here.ClassOnlyEnum input) => 0 == (Int32)input;
    }
}
// <auto-generated />
#nullable enable
using System.Diagnostics.CodeAnalysis;

namespace Some.Namespace.Here;

public static partial class ExtensionsOnlyEnumExtensions
{
    public static string GetString(this Some.Namespace.Here.ExtensionsOnlyEnum value)
        => value switch
        {
            Some.Namespace.Here.ExtensionsOnlyEnum.ExtensionsOnly => "ExtensionsOnly",
            _ => value.ToString()
        };

    public static bool TryGetUnderlyingValue(this Some.Namespace.Here.ExtensionsOnlyEnum value, out Int32 underlyingValue)
    {
        switch (value)
        {
            case Some.Namespace.Here.ExtensionsOnlyEnum.ExtensionsOnly:
                underlyingValue = 0;
                return true;
        }
        underlyingValue = default;
        return false;
    }

    public static Int32 GetUnderlyingValue(this Some.Namespace.Here.ExtensionsOnlyEnum value)
    {
        if (!TryGetUnderlyingValue(value, out Int32 underlyingValue))
            throw new ArgumentOutOfRangeException($"Invalid value: {value}");

        return underlyingValue;
    }
}
